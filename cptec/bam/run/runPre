#! /bin/bash

#-------------------------------------------------------------------------------------------------#
#                         Brazilian global Atmospheric Model - BAM_V2.2.1                         #
#-------------------------------------------------------------------------------------------------#
# Descrição:                                                                                      #
#     Script para executar o pré-processamento do BAM                                             #
#                                                                                                 #
# Uso:                                                                                            #
#     ./runPre TRC LV LABELI PREFIX TOTAL SmoothTopo GDASOnly RESIN KMIN                          #
#                                                                                                 #
# Exemplo:                                                                                        #
#     ./runPre 126 28 2012123118 SMT 1 T F 574 64                                                 #
#     ./runPre 299 64 2020061300 SMT 1 T F 1534 64                                                #
#                                                                                                 #
# Opções:                                                                                         #
#     * TRC.......: resolução espectral das previsões (eg., 62, 126, 213, 299, 666)               #
#     * LV........: resolução vertical das previsões (eg., 28, 42, 64, 96)                        #
#     * LABELI....: data da análise (eg., 2013010100)                                             #
#     * PREFIX....: prefixo da análise (eg., NMC, CPT, AVN)                                       #
#     * TOTAL.....: 1 - tudo (todos os processos); 0 - parcial (apenas alguns processos)          #
#                   2 - debug                                                                     #
#                   veja o arquivo namelist.runPre para mais informações ou mais abaixo           #
#     * SmoothTopo: flag lógica para realizar a suavização da topografia                          #
#                   (T ou F eg., usar quando a análise não for produzida pelo CPTEC)              #
#     * GDASOnly..: flag lógica para escrever apenas os arquivos de análises espectrais           #
#                   para o BAM (T or F)                                                           #
#     * RESIN.....: resolução espectral da análise (eg., 62, 126, 213, 299, 666)                  #
#     * KMIN......: resolução vertical das análises (eg., 28, 42, 64, 96)                         #
#                                                                                                 #
# Notas:                                                                                          #
#     * Até 14/Jan/2015 às 06Z (2015011406) as análises do NCEP estão na resolução TQ00574L064;   #
#       após esta data, as análises passam a ter a resolução TQ1534L064. A partir desta data, o   #
#       arquivo de temperatura da superfície do mar (TSM) lido é o                                #
#       rtgssthr_grb_0.083.grib2.${DATA} (observe a resolução: 0.083 graus) e o arquivo de neve   #
#       (SNOW) não é mais lido (até 2015011400, eram lidos os arquivos gdas1.T00Z.sstgrb2.${DATA} #
#       e gdas1.T00Z.sstgrb2.${DATA}). Outras informações sobre os novos arquivos de TSM:         #
#       http://www.nco.ncep.noaa.gov/pmb/products/sst/                                            #
#     * Até 19/Jul/2017 às 12Z (2017071912) as análises do NCEP estão no formato espectral, na    #
#       resolução TQ01534L064. A partir desta data, os arquivos de análise passam a serem         #
#       escritos em ponto de grade (utilizando-se a biblioteca nemsio) e o nome dos arquivos      #
#       passam a ser gdas.T${HH}Z.atmanl.nemsio.${DATA}, na mesma resolução. Outras informações   #
#       sobre as alterações dos modelos e produtos disseminados pelo NCEP:                        #
#       https://www.nco.ncep.noaa.gov/pmb/changes/                                                #
#                                                                                                 #
# Revisões:                                                                                       #
#     * 22-06-2016: Khamis, E. G.  - código inicial                                               #
#     * 14-07-2016: Khamis, E. G.  - incluídas funções que tornam o runPre independente de        #
#                                    scripts externos através de um namelist                      #
#                                    no momento, continua dependente apenas do                    #
#                                    run_Chopping_parallel.bash e run_Chopping_serial.bash        #
#     * 21-07-2016: Khamis, E. G.  - runPre independente do run_Chopping_parallel.bash e          #
#                                    run_Chopping_serial.bash                                     #
#     * 26-07-2016: Khamis, E. G.  - inclusão de função que cria um script de submissão para      #
#                                    cada processo                                                #
#     * 28-07-2016: Khamis, E. G.  - mudança na forma de submissão dos processos e inclusão de    #
#                                    função de espera e checagem das saídas                       #
#                                    convém ressaltar que é feita uma busca de "ENDS NORMALLY"    #
#                                    no log do processo. alguns processos, como por exemplo       #
#                                    NormalModes e TopographyGradient, não possuem esse print no  #
#                                    código. esse print será incluído. quem for usar              #
#                                    esse script deverá recompilar o código Fortran com os        #
#                                    prints inclusos                                              #
#     * 20-09-2016: Bastarz, C. F. - corrigida verificação do arquivo de análise quando a         #
#                                    suavização da topografia é realizada (PREFIXO=SMT)           #
#                                    corrigido o numero de processadores por nó do                #
#                                    Chopping_parralel (N=24)                                     #
#                                    generalizado o prefixo dos processos SSTClima,               #
#                                    FLUXCO2Clima, SSTWeekly, SSTMonthlyDirec, SSTDailyDirec      #
#                                    e TopographyGradient (modificacões feitas também no script   #
#                                    namelist.runPre)                                             #
#                                  - inclusao de testes e verificação da existência do arquivo    #
#                                    de SST                                                       #
#     * 17-02-2020: Bastarz, C. F. - revisão geral para a consolidação da versão e algumas        #
#                                    melhorias                                                    #
#     * 10-03-2020: Bastarz, C. F. - inclusão do processo CO2MonthlyDirec                         #
#     * 09-09-2020: Khamis, E. G.  - adaptação do novo pré na estrutura do BAM v1.4.0             #
#     * 20-04-2021: Khamis, E. G.  - adaptação do novo pré na estrutura do BAM v2.2.1             #
#                                                                                                 #
# TODO:                                                                                           #
#     * validar a funcao fileout para checar as saidas                                            #
#     * incluir numero de processadores e processadores por no' na linha de comando               #
#                                                                                                 #
# DIMNT/CPTEC/INPE, 2021                                                                          #
#-------------------------------------------------------------------------------------------------#

#
# Funções comuns
#
function usageprincipal()
{
  echo ""
  echo -e "\033[34;1m Brazilian global Atmospheric Model - BAM_V2.2.1\033[m"
  echo ""
  echo " Descrição:"
  echo "     Script para executar o pré-processamento do BAM"
  echo ""
  echo " Uso:"
  echo "     ./runPre TRC LV LABELI PREFIX total SmoothTopo GDASOnly RESIN KMIN"
  echo ""
  echo " Exemplo:"
  echo "     ./runPre 299 64 2020061300 SMT 1 T F 1534 64"
  echo ""
  echo " Opções:"
  echo "     * TRC.......: resolução espectral das previsões (eg., 62, 126, 213, 299, 666)" 
  echo "     * LV........: resolução vertical das previsões (eg., 28, 42, 64, 96)" 
  echo "     * LABELI....: data da análise (eg., 2013010100)" 
  echo "     * PREFIX....: prefixo da análise (eg., NMC, CPT, AVN)" 
  echo "     * TOTAL.....: 1 - tudo (todos os processos); 0 - parcial (apenas alguns processos)" 
  echo "                   veja o arquivo namelist.runPre para mais informações ou mais abaixo" 
  echo "     * SmoothTopo: flag lógica para realizar a suavização da topografia" 
  echo "                   (T ou F eg., usar quando a análise não for produzida pelo CPTEC)" 
  echo "     * GDASOnly..: flag lógica para escrever apenas os arquivos de análises espectrais" 
  echo "                   para o BAM (T or F)" 
  echo "     * RESIN.....: resolução espectral da análise (eg., 62, 126, 213, 299, 666)" 
  echo "     * KMIN......: resolução vertical das análises (eg., 28, 42, 64, 96)" 
  echo ""
  echo -e "\033[33;1m DIMNT/CPTEC/INPE, 2021 \033[m"
  echo ""    
}

mostraHelice() 
{
  for i in / - \\ \|
  do
    echo -ne "\033[31;1m"
    echo -ne "\033[1D$i"
    echo -ne "\033[m"
    sleep .1
  done
}

function WaitUntil()
{
   local file
   file=${1}
   file2=${2}
   echo " "
   echo -en "       Aguardando o arquivo ${file2}   "
   itr=0
   while [ ${itr} -eq 0 ] ; do
   while [ \( ! -s ${file} \) ] ; do
      sleep 0.33 | mostraHelice;
      if test ! -e ${file2} ; then
         itr=1
      else
         break
      fi
   done
   done
   echo " "
}

diffdate() 
{
  di=${1}
  df=${2}

  si=$(date --date "${di:0:8} ${di:8:2}:${di:10:2}:${di:12:2}" +%s)
  sf=$(date --date "${df:0:8} ${df:8:2}:${df:10:2}:${df:12:2}" +%s)

  (( horas = (sf - si )/3600 ))
  (( minutos = ( (sf - si ) - horas*3600 )/60 ))
  (( segundos = (sf - si ) - horas*3600 - minutos*60 ))

  if [ $horas    -lt 10 ]; then horas='0'$horas       ; fi
  if [ $minutos  -lt 10 ]; then minutos='0'$minutos   ; fi
  if [ $segundos -lt 10 ]; then segundos='0'$segundos ; fi

  diffd=$horas'h'$minutos'm'$segundos's'
  echo ""
  echo -e "\033[32;1m     Tempo Total do Pré-Processamento: $diffd \033[m"
  echo ""
  echo ""
}

function lenamelist 
{
  auxdir=$1

  sed 's/#.*$//' $auxdir/namelist.runPre | sed 's/[ ]\+//g' | sed '/^$/d' > $auxdir/namelistrp.tmp

  if [ $total -eq 1 ]
  then
    rm -fr $auxdir/listapre 2>&1
    sed -n '/&geral/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&geral//;s/\/.*$//;p;}' $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp
    nl=$(wc -l $auxdir/tmp | awk '{print $1}')
    if [ $nl -gt 0 ]; then
      echo ""
      echo -e "\033[35;1m     ----- Inicio da Leitura da Relacao de Processos -----\033[m"
      echo ""
      echo -e "\033[35;1m     Bloco\033[32;1m geral \033[35;1m\033[m"
      echo ""
      while read linha
      do
        echo "       $linha "| sed 's/=/ = /g'
        eval export $linha
        echo "$linha" | sed 's/=/ = /g' | grep '= 1' | cut -d' ' -f1 >> $auxdir/listapre
      done < $auxdir/tmp
    fi
  fi

  if [ $total -eq 0 ]
  then
    rm -fr $auxdir/listapre 2>&1
    sed -n '/&opt/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&opt//;s/\/.*$//;p;}' $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp
    nl=$(wc -l $auxdir/tmp | awk '{print $1}')
    if [ $nl -gt 0 ]
    then
      echo ""
      echo -e "\033[35;1m     ----- Inicio da Leitura da Relacao de Processos -----\033[m"
      echo ""
      echo -e "\033[35;1m     Bloco\033[32;1m opt \033[35;1m\033[m"
      echo ""
      while read linha
      do
        echo "       $linha "| sed 's/=/ = /g' 
        eval export $linha
        echo "$linha" | sed 's/=/ = /g' | grep '= 1' | cut -d' ' -f1 >> $auxdir/listapre
      done < $auxdir/tmp
    fi
  fi

  if [ $total -eq 2 ]
  then
    rm -fr $auxdir/listapre 2>&1
    sed -n '/&debug/{/\//tc;:a;/\//!{N;ba;};:c;s/.*\&debug//;s/\/.*$//;p;}' $auxdir/namelistrp.tmp  | sed '/^$/d'> $auxdir/tmp
    nl=$(wc -l $auxdir/tmp | awk '{print $1}')
    if [ $nl -gt 0 ]
    then
      echo ""
      echo -e "\033[35;1m     ----- Inicio da Leitura da Relacao de Processos -----\033[m"
      echo ""
      echo -e "\033[35;1m     Bloco\033[32;1m debug \033[35;1m\033[m"
      echo ""
      while read linha
      do
        echo "       $linha "| sed 's/=/ = /g' 
        eval export $linha
        echo "$linha" | sed 's/=/ = /g' | grep '= 1' | cut -d' ' -f1 >> $auxdir/listapre
      done < $auxdir/tmp
    fi
  fi

  # Verifica se o executavel se encontra no pre/exec
  if [ ! -e ${DK_suite}/pre/exec/ParPre_MPI ] 
  then
    echo ""
    echo -e "\033[31;1m     ----- WARNING: falta do executavel ParPre_MPI! -----\033[m"
  #  cp -vf ${DK_suite}/pre/build/ParPre_MPI ${DK_suite}/pre/exec/ 
  fi

  echo ""
  echo -e "\033[35;1m     ----- Fim da Leitura da Relação de Processos-----\033[m"

  rm -f $auxdir/namelistrp.tmp $auxdir/tmp 
}

function spid() 
{
  echo ""
  for i in $(seq 1 1 12)
  do
    host=eslogin$(printf "%02i\n" $i)
    echo "------------ $host ------------"
    ssh $host "ps -u $USER"
    echo "-----------------------------------"
    echo ""
    if [ $host = $HOSTNAME ]
    then
      echo "AVISO: O PID $$ é o próprio runPre que está executando o spid"
      echo ""
      echo ""
    fi 
  done
}

function fileout()
{
  procname=${1}
   
  varname=$procname

  if [ ${procname} = TopoWaterPercNavy ]
  then
    file_out=${dirdata}/pre/dataout/TopoNavy.dat
    file_out2=${dirdata}/pre/dataout/WaterNavy.dat
  fi
  if [ ${procname} = TopoWaterPercGT30 ]
  then
    file_out=${dirdata}/pre/dataout/TopoGT30.dat
    file_out2=${dirdata}/pre/dataout/WaterGT30.dat
  fi
  if [ ${procname} = NormalModes  ]
  then
    file_out=${dirdata}/model/datain/NMI.${TRUNCA}
  fi
  if [ ${procname} = LandSeaMask  ]
  then
    file_out=${dirdata}/pre/dataout/LandSeaMaskNavy.G${prefix}.dat
  fi
  if [ ${procname} = VarTopo ]
  then
    file_out=${dirdata}/pre/dataout/Topography.G${prefix}
  fi
  if [ ${procname} = TopoSpectral ]
  then
    file_out=${dirdata}/model/datain/TopoVariance.G${prefix}
  fi
  if [ ${procname} = Chopping_serial  ]
  then
    file_out=${dirdata}/model/datain/GANL${PREFXI}${DATA}S.unf.${MRES}
    file_out2=${dirdata}/model/datain/OZON${PREFXI}${DATA}S.grd.${pfxgrd}
  fi
  if [ ${procname} = Chopping_parallel  ]
  then
    file_out=${dirdata}/model/datain/GANL${PREFXI}${DATA}S.unf.${MRES}
    file_out2=${dirdata}/model/datain/OZON${PREFXI}${DATA}S.grd.${pfxgrd}
    file_out3=${dirdata}/model/datain/TRAC${PREFXI}${DATA}S.grd.${pfxgrd}
  fi
  if [ ${procname} = VegetationMaskSSiB ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMaskClima.dat
  fi
  if [ ${procname} = VegetationMask ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMask.G${prefix}
  fi
  if [ ${procname} = VegetationMaskSiB2Clima ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMaskClima.dat
  fi
  if [ ${procname} = VegetationMaskSiB2 ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMaskSiB2.G${prefix}
  fi
  if [ ${procname} = VegetationMaskIBISClima ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMaskIBISClima.dat
  fi
  if [ ${procname} = VegetationMaskIBIS ]
  then
    file_out=${dirdata}/pre/dataout/VegetationMaskIBISClima.dat
  fi
  if [ ${procname} = VegetationAlbedoSSiB ]
  then
    file_out=${dirdata}/model/datain/VegetationMask.G${prefix}
  fi
  if [ ${procname} = DeepSoilTemperatureClima ]
  then
    file_out=${dirdata}/pre/dataout/DeepSoilTemperatureClima.dat
  fi
  if [ ${procname} = DeepSoilTemperature ]
  then
    file_out=${dirdata}/model/datain/DeepSoilTemperature.G${prefix}
  fi
  if [ ${procname} = RoughnessLengthClima ]
  then
    file_out=${dirdata}/pre/dataout/RoughnessLengthClima.dat
  fi
  if [ ${procname} = RoughnessLength ]
  then
    file_out=${dirdata}/model/datain/RoughnessLength.G${prefix}
  fi
  if [ ${procname} = SoilMoistureClima ]
  then
    file_out=${dirdata}/pre/dataout/SoilMoistureClima.dat
  fi
  if [ ${procname} = SoilMoisture ]
  then
    file_out=${dirdata}/model/datain/SoilMoisture.G${prefix}
  fi
  if [ ${procname} = AlbedoClima ]
  then
    file_out=${dirdata}/pre/dataout/AlbedoClima.dat
  fi
  if [ ${procname} = Albedo ]
  then
    file_out=${dirdata}/pre/dataout/Albedo.G${prefix}
  fi
  if [ ${procname} = SnowClima ]
  then
    file_out=${dirdata}/model/datain/Snow${DATA}S.unf.G${prefix}
  fi
  if [ ${procname} = SSTClima ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/model/datain/SSTClima$datt.G${prefix}
  fi
  if [ ${procname} = FLUXCO2Clima ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/model/datain/FLUXCO2Clima$datt.G${prefix}
  fi
  if [ ${procname} = OCMClima ]
  then
    datt=$(echo ${DATA} |cut -c 1-8)
    file_out=${dirdata}/model/datain/ocean_depth.G${prefix}
  fi
  if [ ${procname} = SSTWeeklyNCEP ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/pre/dataout/SSTWeekly.$datt
  fi
  if [ ${procname} = SSTWeekly ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/model/datain/SSTWeekly$datt.G${prefix}
  fi
  if [ ${procname} = SNOWWeeklyNCEP ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/pre/dataout/SNOWWeekly.$datt
  fi
  if [ ${procname} = SoilMoistureWeeklyCPTEC ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/pre/dataout/SoilMoistureWeekly.$datt 
  fi
  if [ ${procname} = SNOWWeekly ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/model/datain/SNOWWeekly.$datt.G${prefix}
  fi
  if [ ${procname} = SoilMoistureWeekly ]
  then
    datt=${DATA:0:8}
    file_out=${dirdata}/model/datain/SoilMoistureWeekly.$datt.G${prefix}
  fi
  if [ ${procname} = CLimaSoilMoistureClima ]
  then
    file_out=${dirdata}/pre/dataout/CLimaSoilMoistureClima.dat
  fi
  if [ ${procname} = CLimaSoilMoisture ]
  then
    file_out=${dirdata}/model/datain/CLimaSoilMoisture.G${prefix}
  fi
  if [ ${procname} = TemperatureClima ]
  then
    file_out=${dirdata}/pre/dataout/TemperatureClima.dat
  fi
  if [ ${procname} = Temperature ]
  then
    file_out=${dirdata}/model/datain/Temperature.G${prefix}
  fi
  if [ ${procname} = DeltaTempColdestClima ]
  then
    file_out=${dirdata}/pre/dataout/DeltaTempColdestClima.dat
  fi
  if [ ${procname} = DeltaTempColdest ]
  then
    file_out=${dirdata}/model/datain/DeltaTempColdes.G${prefix}
  fi
  if [ ${procname} = NDVIClima ]
  then
    file_out=${dirdata}/pre/dataout/NDVIClima.dat
  fi
  if [ ${procname} = NDVI ]
  then
    file_out=${dirdata}/model/datain/NDVI.G${prefix}
  fi
  if [ ${procname} = PorceClayMaskIBISClima ]
  then
    file_out=${dirdata}/pre/dataout/PorceClayMaskIBISClima.dat
  fi
  if [ ${procname} = PorceClayMaskIBIS ]
  then
     file_out=${dirdata}/model/datain/PorceClayMaskIBIS.G${prefix}
  fi
  if [ ${procname} = PorceClayMaskSiB2Clima ]
  then
    file_out=${dirdata}/pre/dataout/PorceClayMaskSiB2Clima.dat
  fi
  if [ ${procname} = PorceClayMaskSiB2 ]
  then
    file_out=${dirdata}/model/datain/PorceClayMaskSiB2.G${prefix}
  fi
  if [ ${procname} = PorceSandMaskIBISClima ]
  then
    file_out=${dirdata}/pre/dataout/PorceSandMaskIBISClima.dat
  fi
  if [ ${procname} = PorceSandMaskIBIS ]
  then
    file_out=${dirdata}/model/datain/PorceSandMaskIBIS.G${prefix}
  fi
  if [ ${procname} = PorceSandMaskSiB2Clima ]
  then
    file_out=${dirdata}/pre/dataout/PorceSandMaskSiB2Clima.dat
  fi
  if [ ${procname} = PorceSandMaskSiB2 ]
  then
    file_out=${dirdata}/model/datain/PorceSandMaskSiB2.G${prefix}
  fi
  if [ ${procname} = SoilTextureMaskSiB2Clima ]
  then
    file_out=${dirdata}/pre/dataout/SoilTextureMaskClima.dat
  fi
  if [ ${procname} = SoilTextureMaskSiB2 ]
  then
    file_out=${dirdata}/model/datain/SoilTextureMaskSiB2.G${prefix}
  fi
  if [ ${procname} = SSTMonthlyDirec ]
  then
    DATA1=${DATA:0:8}
    file_out=${dirdata}/model/datain/SSTMonthlyDirec${DATA1}.G${prefix}
  fi
  if [ ${procname} = SSTDailyDirec ]
  then
    DATA1=${DATA:0:8}
    file_out=${dirdata}/model/datain/SSTDailyDirec${DATA1}.G${prefix}
  fi
  if [ ${procname} = TopographyGradient ] 
  then
    file_out=${dirdata}/model/datain/TopographyGradient${DATA}.G${prefix}
  fi
  if [ ${procname} = CO2MonthlyDirec ] 
  then
    DATA1=${DATA:0:8}
    file_out=${dirdata}/model/datain/CO2MonthlyDirec${DATA1}.G${prefix}
  fi
}

function crianml() 
{ 
  modules=${1}

  echo ""
  echo -e "\033[35;1m     ----- Cria namelist -----\033[m"

  rm -f ${DK_suite}/pre/exec/PRE_run.nml
  
  cp -pfr ${onde}/PRE_run.nml_default ${DK_suite}/pre/exec

  echo -e "\033[35;1m     ----- Configurando o arquivo \033[32;1m PRE_run.nml \033[35;1m\033[m"
  while read linha2
  do
    echo "  $linha2" | sed s/'${modulesToRun}'/$modules/g        \
                     | sed s/'${IM}'/$IM/g                       \
                     | sed s/'${JM}'/$JM/g                       \
                     | sed s,'${dirdata}',"$dirdata",g           \
                     | sed s/'${RESOUT}'/$RESOUT/g               \
                     | sed s/'${KMOUT}'/$KMOUT/g                 \
                     | sed s/'${RESO}'/$RESO/g                   \
                     | sed s/'${RESIN}'/$RESIN/g                 \
                     | sed s/'${KMIN}'/$KMIN/g                   \
                     | sed s/'${GetOzone}'/$GetOzone/g           \
                     | sed s/'${GetTracers}'/$GetTracers/g       \
                     | sed s/'${GrADS}'/$GrADS/g                 \
                     | sed s/'${GrADSOnly}'/$GrADSOnly/g         \
                     | sed s/'${GDASOnly}'/$GDASOnly/g           \
                     | sed s/'${SmoothTopo}'/$SmoothTopo/g       \
                     | sed s/'${RmGANL}'/$RmGANL/g               \
                     | sed s/'${SetLinear}'/$SetLinear/g         \
                     | sed s/'${SetLinearGrid}'/$SetLinearGrid/g \
                     | sed s/'${DataGDAS}'/$DataGDAS/g           \
                     | sed s/'${DATA}'/$DATA/g                   \
                     | sed s/'${UTC}'/$UTC/g                     \
                     | sed s/'${AnlPref}'/$AnlPref/g             \
                     | sed s,'${dirhome}',"$dirhome",g           \
                     | sed s/'${MendCut}'/$MendCut/g             \
                     | sed s/'${SmthPerCut}'/$SmthPerCut/g       \
                     | sed s/'${PREFIXO}'/$PREFIXO/g 
  done < ${DK_suite}/pre/exec/PRE_run.nml_default > ${DK_suite}/pre/exec/PRE_run.nml
    
  if test ! -s ${DK_suite}/pre/exec/PRE_run.nml
  then
    echo -e "\033[31;1m     ----- Problema na criacao do arquivo! -----\033[m"
    exit 1 
  else
    echo " /" >>  ${DK_suite}/pre/exec/PRE_run.nml  
    echo -e "\033[35;1m     ----- arquivo pronto -----\033[m" 
    rm -f ${DK_suite}/pre/exec/PRE_run.nml_default
  fi
}

function GetSNOW() 
{
  #
  #  Run GetSNOW.ksh
  #  To deGRIB NCEP SNOW file with the script GetSNOW.ksh
  #  and to format properly the file for SNOWWeekly)
  #
  YYYYMMDD=${DATA:0:8}
  hh12=${DATA:8:2}
  
  hh00=00
  
  cd ${dirdata}/pre/datain
  
  # Possible SNOW GRIB files:
  grbfiles=(gdas1.T${hh00}Z.snogrd.${YYYYMMDD}${hh00}  gdas1.T${hh12}Z.snogrd.${YYYYMMDD}${hh12}  gdas1.T${hh00}Z.snogrd.${YYYYMMDD}${hh12}  \
            gdas1.T${hh00}Z.snogrb.${YYYYMMDD}${hh00}  gdas1.T${hh12}Z.snogrb.${YYYYMMDD}${hh12}  gdas1.T${hh00}Z.snogrb.${YYYYMMDD}${hh12}  \
            gdas1.T${hh00}Z.snogrb2.${YYYYMMDD}${hh00} gdas1.T${hh12}Z.snogrb2.${YYYYMMDD}${hh12} gdas1.T${hh00}Z.snogrb2.${YYYYMMDD}${hh12})
  
  for gfile in ${grbfiles[@]}
  do
    if [ -s ${gfile} -a ${gfile:10:8} = .snogrb. ]
    then
      ${dirgrads}/wgrib -s -4yr -d 1 -ieee gdas1.T${hh12}Z.snogrb.${YYYYMMDD}${hh12}
      mv dump gdas1.T${hh12}Z.snogrd.${YYYYMMDD}${hh12}
      echo "SNOW file found ${gfile}"
      break
    elif [ -s ${gfile} -a ${gfile:10:9} = .snogrb2. ]
    then
      ${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns ${gfile} -ieee gdas1.T${hh12}Z.snogrd.${YYYYMMDD}${hh12}
      echo "SNOW file found ${gfile}"
      break
    elif [ -s ${gfile} -a ${gfile:10:8} = .snogrd. ]
    then 
      echo "SNOW file found ${gfile}"
      break
    else
      echo "SNOW file not found!"
    fi
  done

  date=$(awk 'BEGIN {print substr("'${rec}'",7,10)}')
}

function GetSoilMoisture() 
{
  #
  #  Run GetSoilMoisture.ksh
  #  To deGRIB CPTEC SoilMoisture file with the script GetSoilMoisture.ksh
  #  and to format properly the file for SoilMoistureWeekly)
  #
  YYYYMMDD=${DATA:0:8}
  hh12=${DATA:8:2}
  hh=00

  # cd ${dirdata}/pre/datain
}

function GetSST() 
{
  #
  #  Run GetSST.ksh
  #  To deGRIB NCEP SST file with the script GetSST.ksh
  #  and to format properly the file for SSTWeekly)
  #
  YYYYMMDD=${DATA:0:8}
  hh12=${DATA:8:2}
  
  hh00=00
  
  cd ${dirdata}/pre/datain
  
  # Possible SST GRIB files:
  grbfiles=(gdas1.T${hh00}Z.sstgrd.${YYYYMMDD}${hh00}  gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}  gdas1.T${hh00}Z.sstgrd.${YYYYMMDD}${hh12}  \
            gdas1.T${hh00}Z.sstgrb.${YYYYMMDD}${hh00}  gdas1.T${hh12}Z.sstgrb.${YYYYMMDD}${hh12}  gdas1.T${hh00}Z.sstgrb.${YYYYMMDD}${hh12}  \
            gdas1.T${hh00}Z.sstgrb2.${YYYYMMDD}${hh00} gdas1.T${hh12}Z.sstgrb2.${YYYYMMDD}${hh12} gdas1.T${hh00}Z.sstgrb2.${YYYYMMDD}${hh12} \
            rtgssthr_grb_0.5.grib2.${YYYYMMDD} rtgssthr_grb_0.083.grib2.${YYYYMMDD})
  
  for gfile in ${grbfiles[@]}
  do
    if [ -s ${gfile} -a ${gfile:10:8} = .sstgrb. ]
    then 
      ${dirgrads}/wgrib -s -4yr -d 1 -ieee ${gfile}
      mv dump gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}
      echo "SST file found ${gfile}"
      break
    elif [ -s ${gfile} -a ${gfile:10:9} = .sstgrb2. -o -s ${gfile} -a ${gfile:0:13} = rtgssthr_grb_ ]
    then 
      ${dirgrads}/wgrib2 -s -YY -d 1 -order we:ns ${gfile} -ieee gdas1.T${hh12}Z.sstgrd.${YYYYMMDD}${hh12}
      echo "SST file found ${gfile}"
      break
    elif [ -s ${gfile} -a ${gfile:10:8} = .sstgrd. ]
    then 
      echo "SST file found ${gfile}"
      break
    else
      echo "SST file not found ${gfile}"
    fi
  done
  
  date=$(awk 'BEGIN {print substr("'${rec}'",7,10)}')
}

function criabash() 
{
   export cpu_mpi=$1
   export cpu_node=$2
   export varname=$3
#   num=$(($cpu_mpi+$cpu_node-1))
#   fra=$(($num/$cpu_node))
#   cpu_tot=$(($fra*$cpu_node))
#   echo " "
#   host=`hostname`
#   echo "     ${host}"
#   RUNTM=`date +'%d_%H:%M'`
#
   rm -f ${direxe}/set${varname}.bash > /dev/null 2>&1
   rm -f ${direxe}/Out.MPI${cpu_mpi}_${varname} > /dev/null 2>&1
   rm -f ${direxe}/.${varname}.ok > /dev/null 2>&1

cat <<EOT1 > ${direxe}/set${varname}.bash
#!/bin/bash
#PBS -o ${direxe}/Out.MPI${cpu_mpi}_${varname}
#PBS -j oe
#PBS -l walltime=00:15:00
#PBS -A CPTEC
#PBS -l mppwidth=${cpu_mpi}
###PBS -l mppdepth=1
#PBS -l mppnppn=${cpu_node}
#PBS -V
#PBS -S /bin/bash
#PBS -N ${varname}
#PBS -q pesq

#
.  /opt/modules/default/etc/modules.sh
#module load stat
#module load atp
module load craype-x86-skylake
module list
export OMP_WAIT_POLICY=PASSIVE
#   
#export PBS_SERVER=eslogin13
export KMP_STACKSIZE=128m
#export ATP_ENABLED=1
#ulimit -c unlimited
#
cd ${direxe}
date
time aprun -n ${cpu_mpi} -N ${cpu_node} ${direxe}/${varname} > saida${cpu_mpi}.txt
wait
date
wait
> ${direxe}/.${varname}.ok
rm -f ${direxe}/Dump.* > /dev/null 2>&1 
EOT1

chmod +x ${direxe}/set${varname}.bash

}



#
# Início do Pré-processamento
#

#
# Verifica o número de argumentos passados junto com o script:
# Pelo menos 9 argumentos devem ser passados;
# Caso contrário, será chamada a função para imprimir o cabeçalho e o script é encerrado
#
if [ "$#" -lt 9 ]
then
  if [ 'x'$1 = 'xspid' ]
  then
    spid
    exit 0
  else
    usageprincipal
    exit 1
  fi
fi

#
# Pegando os argumentos da linha de comando
#
export TRC=${1}             
export LV=${2}              
export DATA=${3}       # LABELI initial data YYYYMMDDHH 
export PREFIXO=${4}    # PREFIX   
export total=${5}         
export SmoothTopo=${6} # Flag to Performe Topography Smoothing

if [ ${SmoothTopo} == "T" ]
then
  export PREFIXO=SMT 
fi

export GDASOnly=${7}   # Flag to Only Produce Input CPTEC Analysis File
export RESIN=${8}      # Spectral Horizontal Resolution of Input Data
export KMIN=${9}       # Number of Layers of Input Data
#cpuMPI=${10}           # cpu_mpi  : numero de processadores    
#cpuNODE=${11}          # cpu_node : processadores por no'

#
# Ajuste das variáveis de ambiente
#
CASE=$(echo ${TRC} ${LV} | awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }')

export PATHENV=$(dirname $(readlink -e ${0})) # Local (path) onde está este script
export FILEENV=${PATHENV}/EnvironmentalVariablesMCGA
export PATHBASE=$(cd ${PATHENV}; cd ../; pwd)

. ${FILEENV} ${CASE} ${PREFIXO}

export direxe=${DK_suite}/pre/exec     # ${PATHENV}
export dir_testcase=${PATHBASE}
export exe_name=ParPre_MPI
#export QSUB=/opt/pbs/default/bin/qsub

export cpu_mpi_aux=240       #${cpuMPI}   # 24   # numero de processadores
export cpu_node_aux=40       #${cpuNODE} # 24(tupa) | 40(xc50)   # processadores por no'


cd ${DK_suite}/pre/exec

#
# Ajustes do Chopping
#
typeset -x prefi

export RESOUT=$(echo ${1} | awk '{print $1/1}')
export KMOUT=$(echo ${2} | awk '{print $1/1}')

export GetOzone=T      # Flag to Produce Ozone Files
export GetTracers=T    # Flag to Produce Tracers Files
export GrADS=T         # Flag to Produce GrADS Files
export GrADSOnly=F     # Flag to Only Produce GrADS Files (Do Not Produce Inputs for Model)
export RmGANL=F        # Flag to Remove GANL File if Desired
export MendCut=$(echo $RESOUT | awk '{ print (int(1/((5+(40000/($1*3)))*(3/(40000)))) +1) }') # FLAG to Spectral Resolution Cut Off for Topography Smoothing
#export MendCut=`echo $RESOUT | awk '{ print (int(1/((8+(1/($1))))) +1) }' ` #! FLAG to Spectral Resolution Cut Off for Topography Smoothing
export SmthPerCut=0.12 # FLAG to Percentage for Topography Smoothing

export SetLinear=FALSE
export RESO=${1}

case ${RESOUT} in
21)   export IM=64;   export JM=32;   export timestep=3600;;
31)   export IM=96;   export JM=48;   export timestep=1800;;
42)   export IM=128;  export JM=64;   export timestep=1200;;
62)   export IM=192;  export JM=96;   export timestep=900;;
106)  export IM=320;  export JM=160;  export timestep=600;;
126)  export IM=384;  export JM=192;  export timestep=450;;
133)  export IM=400;  export JM=200;  export timestep=450;;
159)  export IM=480;  export JM=240;  export timestep=360;;
170)  export IM=512;  export JM=256;  export timestep=360;;
213)  export IM=640;  export JM=320;  export timestep=300;;
254)  export IM=768;  export JM=384;  export timestep=240;;
299)  export IM=900;  export JM=450;  export timestep=200;;
319)  export IM=960;  export JM=480;  export timestep=180;;
341)  export IM=1024; export JM=512;  export timestep=180;;
382)  export IM=1152; export JM=576;  export timestep=150;;
511)  export IM=1536; export JM=768;  export timestep=120;;
533)  export IM=1600; export JM=800;  export timestep=120;;
666)  export IM=2000; export JM=1000; export timestep=90;;
863)  export IM=2592; export JM=1296; export timestep=60;;
1279) export IM=3840; export JM=1920; export timestep=20;;
1332) export IM=4000; export JM=2000; export timestep=20;;
*) echo "Spectral resolution (TRC=${RESOUT}) is not contemplated...";exit 0;;
esac

if [[ "$SetLinear" = "TRUE" ]]
then
  export TRUNC=$(echo ${RESOUT} |awk '{ printf("TL%4.4d\n",$1)  }')
  export MRES=$(echo ${TRC} ${LV} |awk '{ printf("TL%4.4dL%3.3d\n",$1,$2)  }')
else
  export TRUNC=$(echo ${RESOUT} |awk '{ printf("TQ%4.4d\n",$1)  }')
  export MRES=$(echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }')
fi

export TRUNCA=$(echo ${TRC} ${LV} |awk '{ printf("T%4.4dL%3.3d\n",$1,$2)  }')

export pfxgrd=$(echo ${JM} ${LV}  |awk '{ printf("G%5.5dL%3.3d\n",$1,$2)  }')

prefix=$(echo ${JM} |awk '{ printf("%5.5d\n",$1)  }')

#
# As variáveis DataGDAS e AnlPref a seguir, devem ser ajustadas no script 
# EnvironmentalVariablesMCGA antes de executar o script runPre
#
if [ -z "${DataGDAS}" ]
then
  export DataGDAS="Spec" # Spec == Anl. Spec. NCEP; Grid == Anl. Grid NCEP
fi 

if [ -z "${AnlPref}" ]
then
  export AnlPref="gdas1" # gdas1/gblav == Anl. Spec. NCEP; gdas/gblav == Anl. Grid. NCEP
fi 

export dirhome=${HOME_suite}/pre
export dirdata=${DK_suite}
export dirgrads=${DIRGRADS}

#
# Opções da máquina
#
export MAQUI=Linux
#export PBS_SERVER=${pbs_server2}

export onde=$PATHBASE/run

lenamelist ${onde} # essa leitura gera uma lista com os processos escolhidos para rodar no pre

#
# Ajustes de caminhos nos namelists dos processos SST[Daily,Monthly]Direc e CO2MonthlyDirec
#
#foiv2m=${dirdata}/pre/datasst/oiv2monthly/sstmtd.nml
#if [ -s ${foiv2m} ]; then sed -i "/drsst/c\ drsst='${dirdata}/pre/datasst/oiv2monthly/ '," ${foiv2m}; fi 

#foiv2d=${dirdata}/pre/datasst/oiv2daily/sstmtd.nml
#if [ -s ${foiv2d} ]; then sed -i "/drsst/c\ drsst='${dirdata}/pre/datasst/oiv2daily/ '," ${foiv2d}; fi 

#fco2m=${dirdata}/pre/dataco2/oiv2monthly/co2mtd.nml
#if [ -s ${fco2m} ]; then sed -i "/DRCO2/c\ DRCO2='${dirdata}/pre/dataco2/oiv2monthly/ '," ${fco2m}; fi 

#fco2d=${dirdata}/pre/dataco2/oiv2daily/co2mtd.nml
#if [ -s ${fco2d} ]; then sed -i "/DRCO2/c\ DRCO2='${dirdata}/pre/dataco2/oiv2daily/ '," ${fco2d}; fi 



#export NOM=$(cat ${onde}/listapre | wc -l) 
#echo ${NOM}

export modulesToRunAux=""
while read linha
do
  modulesToRunAux+="'${linha}',"
done < ${onde}/listapre

#echo ${modulesToRun} | tr ' ' '\n' | sort | tr '\n' ' ' < ${onde}/listaprel
#export modulesToRun=$(cat `${onde}/listaprel`)
#export modulesToRun=$(echo ${modulesToRunAux} | tr ' ' '\n' | sort | tr '\n' ' ')
#echo ${modulesToRun}


crianml ${modulesToRunAux}

sed -i 's/!.*//'                ${DK_suite}/pre/exec/PRE_run.nml # remove tudo na linha apos o caracter ! 
sed -i '/^\s*$/d'               ${DK_suite}/pre/exec/PRE_run.nml  
sed -i '/modulesToRun/s/,/, /g' ${DK_suite}/pre/exec/PRE_run.nml # cria um espaco apos a virgula
sed -i 's/^ \+//'               ${DK_suite}/pre/exec/PRE_run.nml # retira espacos em branco no inicio da linha
tail -n 1 ${DK_suite}/pre/exec/PRE_run.nml | wc -c \
              | xargs -I {} truncate ${DK_suite}/pre/exec/PRE_run.nml -s -{}  # remove ultima linha

rm -f ${DK_suite}/pre/exec/PRE_cfg.nml
cp -pfr ${onde}/PRE_cfg.nml_default ${DK_suite}/pre/exec/PRE_cfg.nml
sed -i s/nproc/${cpu_mpi_aux}/g     ${DK_suite}/pre/exec/PRE_cfg.nml  # atencao, deve ser o mesmo numero de processadores do criabash
rm -f ${DK_suite}/pre/exec/PRE_cfg.nml_default

rm -f ${DK_suite}/pre/exec/sstmtd.nml
cp -pfr ${onde}/sstmtd.nml_default ${DK_suite}/pre/exec/sstmtd.nml
sed -i s,'${dirdata}',"$dirdata",g ${DK_suite}/pre/exec/sstmtd.nml  
rm -f ${DK_suite}/pre/exec/sstmtd.nml_default

#
#  Cria o script de submissão
#
echo ""
echo -e "     \033[33;1mCria .bash e submete o processo: criabash ${cpu_mpi_aux} ${cpu_node_aux} ${exe_name}\033[m"
criabash ${cpu_mpi_aux} ${cpu_node_aux} ${exe_name}


#while read linha
#do
#  if [ ${linha} = SSTWeeklyNCEP ]
#  then
#    GetSST
#  fi
#  if [ ${linha} = SNOWWeeklyNCEP ]
#  then
#    GetSNOW
#  fi
#  if [ ${linha} = SoilMoistureWeeklyCPTEC ]
#  then
#    GetSoilMoisture
#  fi
#done < ${onde}/listapre


date +%Y%m%d%H%M%S > ${onde}/tempoi


echo ${DATA}

#
#  submete processo 
#
rm -f ${direxe}/Out.MPI${cpu_mpi_aux}_${exe_name} > /dev/null 2>&1
rm -f ${direxe}/saida${cpu_mpi_aux}.txt > /dev/null 2>&1
#export QPIDpre=$(${QSUB} ${direxe}/set${varname}.bash)
#echo "     QPIDpre: ${QPIDpre}"
${QSUB} -W block=true ${direxe}/set${exe_name}.bash
error=$?
if [ ${error} -ne 0 ]; then
  echo "       ERROR: ${exe_name} crashed  Exit status=${error}"
  exit ${error}
fi
#WaitUntil ${direxe}/Out.MPI${cpu_mpi_aux}_${exe_name} ${direxe}/.${exe_name}.ok
until [ -s ${direxe}/Out.MPI${cpu_mpi_aux}_ParPre_MPI ]; do sleep 1s; done

chmod 755 -R ${direxe}
cat ${direxe}/saida${cpu_mpi_aux}.txt | grep -i error 
cat ${direxe}/saida${cpu_mpi_aux}.txt | grep -i warning
ls ${dirdata}/model/datain | wc -l   

#while read linha
#do
#  echo -e "   > \033[33;1mChecando saída do processo: ${linha}\033[m"
#  echo ""
#  fileout ${linha}
#done < ${onde}/listapre

date +%Y%m%d%H%M%S > ${onde}/tempof

diffdate $(cat ${onde}/tempoi) $(cat ${onde}/tempof)

rm -f ${onde}/tempoi ${onde}/tempof
rm -f ${direxe}/.${exe_name}.ok > /dev/null 2>&1
rm -f ${onde}/listapre 2>&1

exit 0
