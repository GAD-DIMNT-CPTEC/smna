#!/bin/bash -x
#help#
#**********************************************************************************************************#
#                                                                                                          #
# script to run CPTEC Post-processing on PC Clusters under MPI Scali                                       #
# and Sun Grid Engine without OpenMP                                                                       #
#                                                                                                          #
# assumptions: assume present but NOT at the same directory:                                               #
#              $FEXE/PostGrib (Post-processing Executable file)                                            #
#              $FSCR/POSTIN-GRIB (Post-processing input Namelist file)                                     #
#                                                                                                          #
# usage:runPos cpu_mpi cpu_node task_omp name   TRC LV  LABELI     LABELW     LABELF      NMC START FIRST  #
#       runPos    1       1          1   posbam 126 28  2011120112 2011120712 2011120712  NMC COLD   1     #
# where:                                                                                                   #
# cpu_mpi : integer, the desired number of mpi processes                                                   #
# cpu_node: integer, the desired number of mpi processes per shared memory node                            #
# task_omp: numero de processos openmp por processos mpi                                                   # 
# name    : Name of the Proccess (job)                                                                     #
# TRC     : Spectral resolution(Number of wave)                                                            #
# LV      : Vertical resolution(Number of layer in atmosphere)                                             #
# LABELI  : initial data YYYYMMDDHH                                                                        #
# LABELW  : restart data YYYYMMDDHH (if COLD ---> LABELW=LABELF)                                           #
# LABELF  : Final   data YYYYMMDDHH                                                                        #
# NMC     : prefix of files   NMC                                                                          #
# START   : type of pos-processing (COLD WARM)                                                             #
# FIRST   : ---                                                                                            #
#**********************************************************************************************************#
#help#
#
#       Help:
#
if [ "${1}" = "help" -o -z "${1}" ]
then
  cat < ${0} | sed -n '/^#help#/,/^#help#/p'
  exit 1
else
  TRC=`echo ${5} | awk '{print $1/1}'`   
fi
if [ -z "${6}" ]
then
  echo "LV is not set" 
  exit 2
else
  LV=`echo ${6} | awk '{print $1/1}'`    
fi

if [ -z "${7}" ]
then
  echo "LABELI is not set" 
  exit 3
else
  export LABELI=${7}  
fi

if [ -z "${8}" ]
then
  echo "LABELW is not set" 
  exit 3
else
  export LABELW=${8}  
fi

if [ -z "${9}" ]
then
  echo "LABELF is not set" 
  exit 3
else
  export LABELF=${9}  
fi

if [ -z "${10}" ]
then
  echo "PREFIC is not set" 
  exit 3
else
  export PREFIC=${10}  
fi

if [ -z "${11}" ]
then
  echo "START is not set" 
  exit 3
else
  export START=${11}  
fi
if [ -z "${12}" ]
then 
  echo "FIRST is not set" 
  exit 3
else 
  export FIRST=${12}
fi

if [ "$#" == 13 ]
then 
  export hold=${13}    
  export FIRST=${13}
  export hold=""
else 
  export hold=""
fi
echo $hold

#
# SETTING THE APPROPRIATED ENVIRONMENT
#
CASE=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
PATHA=`pwd`
export FILEENV=`find ${PATHA} -name EnvironmentalVariablesMCGA -print`
export PATHENV=`dirname ${FILEENV}`
export PATHBASE=`cd ${PATHENV};cd ../;pwd`
. ${FILEENV} ${CASE} ${PREFIC}
cd ${HOME_suite}/run
RUNTM=`date +'%Y%m%d%T'`
yi=`awk 'BEGIN {print substr("'${LABELI}'",1,4)/1}'` ; export yi
mi=`awk 'BEGIN {print substr("'${LABELI}'",5,2)/1}'` ; export mi
di=`awk 'BEGIN {print substr("'${LABELI}'",7,2)/1}'` ; export di
hi=`awk 'BEGIN {print substr("'${LABELI}'",9,2)/1}'` ; export hi

yf=`awk 'BEGIN {print substr("'${LABELF}'",1,4)/1}'` ; export yf
mf=`awk 'BEGIN {print substr("'${LABELF}'",5,2)/1}'` ; export mf
df=`awk 'BEGIN {print substr("'${LABELF}'",7,2)/1}'` ; export df
hf=`awk 'BEGIN {print substr("'${LABELF}'",9,2)/1}'` ; export hf
#Dia juliano
#John Cirillo
#El calendario juliano es un metodo para identificar el dia actual atravas de la cuenta del numero de dias 
#que han pasado desde una fecha pasada y arbitraria. El numero de dias se llama dia juliano, abreviado como DJ.
#El origen, DJ=0, es el 1 de enero de 4713 A.C. (o 1 de enero de -4712, ya que no hubo ano 0). 
#Los dias julianos son muy utiles porque hacen que sea muy sencillo determinar el número de dias entre dos eventos, 
#solo con restar los numeros de sus dias julianos. Hacer ese calculo con el calendario normal (gregoriano) es muy dificil, 
#ya que los dias se agrupan en meses, que contienen un numero variable de dias, complicado ademas por la presencia de los anos bisiestos.
#La conversion entre el calendario normal (gregoriano) y los dias julianos y viceversa, es mejor que sea realizada 
#por un programa escrito concretamente para ello, como el que proporciona KStars Calculadora astronomica. 
#Sin embargo, para quien pueda estar interesado, este es un ejemplo sencillo de conversion entre los calendarios gregoriano y juliano:
#DJ = D - 32075 + 1461*( Y + 4800 + ( M - 14 ) / 12 ) / 4 + 367*( M - 2 - ( M - 14 ) / 12 * 12 ) / 12 - 3*( ( Y + 4900 + ( M - 14 ) / 12 ) / 100 ) / 4
# donde D es el dia (1-31), M es el mes (1-12) y A es el ano (1801-2099). Tenga en cuenta que esta fórmula solo funciona entre los anos 1801 y 2099. 
# Otras fechas anteriores requieren transformaciones mas complicadas.
#Un dia juliano de ejemplo es: DJ 2440588, que corresponde al 1 de enero de 1970.
#Los dias julianos tambien sirven para indicar la hora, expresandose esta como una fraccion de un dia entero,
# siendo las 12 del mediodia el punto cero. Asi, las tres de la tarde del 1 de enero de 1970 es DJ 2440588,125 
#(ya que las tres de la tarde son tres horas despues de mediodia, y 3/24 = 0,125 días). 
#Tenga en cuenta que el dia juliano viene siempre determinado por el tiempo universal y no por el local.
#Los astronomos utilizan ciertos dias julianos como puntos de referencia importantes, llamados epocas. 
#Una de las epocas mas utilizadas se llama J2000, que es el día juliano correspondiente al 1 de enero de 2000, 
# a las 12 del mediodia = DJ 2451545,0.
set +x
declare -a md=( 0 31 28 31 30 31 30 31 31 30 31 30 31 )
let ihour=$hi/1
let houryear=0
let iyear=$yi/1
while [ ${iyear} -le ${yf} ];do

if [[ ${iyear} -eq ${yf}  ]];then
lmon=${mf}
else
lmon=12
fi

let imon=$mi/1
while [ ${imon} -le ${lmon} ];do

if [ ${iyear} -eq ${yf}  ] ; then
   bi=`awk 'BEGIN {print '${iyear}'%4.0 }'` 
   if [ ${imon} -lt ${mf} ]; then
      if [ ${bi} -eq 0  ] && [ ${imon} -eq 2 ]; then
         lday=29
      else
         lday=${md[${imon}]} 
      fi
   else
      lday=${df}
   fi
else
   bi=`awk 'BEGIN {print '${iyear}'%4.0 }'` 
   if [ ${bi} -eq 0  ] && [ ${imon} -eq 2 ]; then
     lday=29
   else
     lday=${md[${imon}]} 
   fi
fi



let iday=$di/1
while [ ${iday} -le ${lday} ];do
##############################################################
      if [ ${iyear} -eq  ${yf} ] && [ ${imon} -eq ${mf} ] && [ ${iday} -le ${df} ]; then
        let lhour=${hf} 
      else
        lhour=23
      fi
while [ ${ihour} -le ${lhour} ];do

let houryear=${houryear}+1

let ihour=${ihour}+1
done
let ihour=0

##############################################################



##############################################################
let iday=${iday}+1
done

let imon=${imon}+1
done

let iyear=${iyear}+1
done

set -x
#En Internet hay mucha mas informacion disponible sobre los dias julianos. Un buen lugar para comenzar es el U.S. Naval Observatory. 
#Si dicho servidor no es encuentra disponible cuando usted lea esto, introduzca «julian day» en su buscador favorito.
#DJ=`expr ( $di - 32075 + 1461*( $yi + 4800 + ( $mi - 14 ) / 12 ) / 4 + 367*( $mi - 2 - ( $mi - 14 ) / 12 * 12 ) / 12 - 3*( ( $yi + 4900 + ( $mi - 14 ) / 12 ) / 100 ) / 4)`
if  [ ${houryear} -le  0 ];then
NEXTDATE=`${caldate} ${LABELI} + 6h yyyymmddhh`
CURRDATE=`${caldate} ${LABELI} + 0h yyyymmddhh`
PREVDATE=`${caldate} ${LABELI} - 6h yyyymmddhh`
else
NEXTDATE=${LABELF}
CURRDATE=${LABELI}
PREVDATE=${LABELW}
fi
echo ${PREVDATE}

# script arguments and directory
DIRRESOL=`echo ${TRC} ${LV} |awk '{ printf("TQ%4.4dL%3.3d\n",$1,$2)  }' `
EXECFILEPATH=${DK_suite}/pos/exec; EXECFILEPATH2=${DK_suite}/pos/exec_${PREFIC}${LABELI}${LABELF};mkdir -p ${EXECFILEPATH2}/setout
SCRIPTFILEPATH=${EXECFILEPATH2}/postg.${PREFIC}.${DIRRESOL}.${MAQUI}
NAMELISTFILEPATH=${HOME_suite}/run
OUTPUTFILEPATH=${HOME_suite}/run/setout/postg${DIRRESOL}.${MAQUI}.${RUNTM}.out
export cpu_mpi=${1};  if [[ -z "${1}"  ]]; then cpu_mpi=24 ; fi
export cpu_node=${2}; if [[ -z "${2}"  ]]; then cpu_node=24; fi
export ThreadsperMPITASK=$3; if [[ -z "${3}"  ]]; then cpu_node=1; fi
export RES=$4

# total cpus and nodes

export mpi_no=$1
export cpu_node=$2
export ThreadsperMPITASK=$3
export RES=$4
export cputot_mpi_openmp=`echo ${mpi_no} ${ThreadsperMPITASK} | awk '{print $1*$2}'`
export mpi_node=`echo ${cpu_node} ${ThreadsperMPITASK} | awk '{print $1 / $2}'`
export nodes=`echo ${cputot_mpi_openmp} ${cpu_node} |  awk '{print $1 / $2}'`
export mpi_pes=`echo ${cputot_mpi_openmp} ${ThreadsperMPITASK} |  awk '{print $1 / $2}'`

num=$(($cpu_mpi+$cpu_node-1))
fra=$(($num/$cpu_node))
cpu_tot=$(($fra*$cpu_node))
echo fila=mpi-npn${cpu_node} total cpus=${cpu_tot}
export PBS_SERVER=${pbs_server1}
optserver=`printf "$PBS_SERVER \n" | cut -c1-3`
if [[ (${optserver} = "aux") ]]; then
export MPPBS="#"
else
export MPPBS="#PBS -l mppwidth=${cpu_mpi}"
fi

host=`hostname`

export aspa="'"  
export GPOS=GPOS
export trunc=$TRC
export lev=$LV
if [ ${START} = "COLD" ] ;then
export nffrs=-1        
export nfbeg=-1
else
export nffrs=1        
export nfbeg=1
fi
if [ -z "${PREFXO}" ] ;then
export PREFX="NMC" 
else
export PREFX="${PREFXO}" 
fi 
export nfend=60000                                                                    # number of forecasted files to be post-processed
export datain=${DK_suite2}/model/dataout/${DIRRESOL}/${LABELI}-${PREVDATE}    # main dataout directory
export datalib=${DK_suite}/pos/datain                  # main dataout directory
export dataout=${DK_suite2}/pos/dataout/${DIRRESOL}/${LABELI}; mkdir -p ${dataout}     # main dataout directory
export res=-0.5              # if res >  0 Define output resolution (deg)
export ENS=".TRUE."         # ensemble products => TRUE, only for AVN, 0?P, 0?N PREFX
export RegIntIn=".FALSE."    # flag to interpolate outputs on regular grid (.TRUE.)
                             # .FALSE. to get outputs on Gaussian grid
export Binary=".FALSE."      # output binary format ! False -> Grib (Default)

export req='p'  #req   ='p',          ! flag to select requested field file (p, s, c, e g or nothing)
                 #       !   p - use file rfd.pnt
                 #       !   s - use file rfd.sfc
                 #       !   c - use file rfd.clm
                 #       !   e - use file rfd.eta
                 #       !   g - use file rfd.ens
                 #       !     - use file rfd

cat ${NAMELISTFILEPATH}/POSTIN-GRIB | awk '{  
      if (substr($1,1,5) == "trunc")
       {
     	"echo $trunc" | getline trunc
	"echo $aspa" | getline aspa    
         printf("  trunc    =%sTQ%4.4d%s,  !TRC   : three-digit triangular truncation\n",aspa,trunc,aspa)
       }
      else if (substr($1,1,3) == "lev")
       {
     	"echo $lev" | getline lev      
	"echo $aspa" | getline aspa    
         printf("  lev     =%sL%3.3d%s,       ! vertical layers = LXXX\n",aspa,lev,aspa)
       }
      else if (substr($1,1,6) == "labeli")
       {
        "echo $aspa" | getline aspa
     	"echo $LABELI" | getline LABELI       
         printf("  labeli=%s%s%s , ! initial forecasting label (yyyymmddhh)\n",aspa,LABELI,aspa)
       }
      else if (substr($1,1,6) == "labelf")
       { 
        "echo $aspa" | getline aspa
     	"echo $LABELF" | getline LABELF
         printf("  labelf=%s%s%s , ! final forecasting label (yyyymmddhh)\n",aspa,LABELF,aspa)
       }
      else if (substr($1,1,5) == "prefx")
       { 
        "echo $aspa" | getline aspa
     	"echo $PREFX" | getline PREFX
         printf("  prefx =%s%s%s,        ! preffix for input and output files\n",aspa,PREFX,aspa)
       }
      else if (substr($1,1,3) == "req")
       { 
        "echo $aspa" | getline aspa
     	"echo $req" | getline req
         printf(" req   =%s%s%s,          ! flag to select requested field file (p, s, c, e or nothing)\n",aspa,req,aspa)
       }
      else if (substr($1,1,5) == "nfend")
       { 
     	"echo $nfend" | getline nfend
         printf("  nfend=%d,         ! number of forecasted files to be post-processed\n",nfend)
       }
      else if (substr($1,1,5) == "nffrs")
       { 
     	"echo $nffrs" | getline nffrs
         printf("  nffrs=%d,            ! value to indicated if model use or not initialization\n",nffrs)
       }
      else if (substr($1,1,5) == "nfbeg")
       { 
     	"echo $nfbeg" | getline nfbeg
         printf("  nfbeg=%d,           ! number of the first forecasted file to be post-processed\n",nfbeg)
       }
      else if (substr($1,1,3) == "res")
       { 
     	"echo $res" | getline res
         printf("  res=%8.5f,            ! if res >  0 Define output resolution (deg)\n",res)
       }
      else if (substr($1,1,3) == "ENS")
       { 
     	"echo $ENS" | getline ENS
         printf("  ENS=%s,            ! ensemble products => TRUE, only for AVN, 0?P, 0?N prefx\n",ENS)
       }
      else if (substr($1,1,8) == "RegIntIn")
       { 
     	"echo $RegIntIn" | getline RegIntIn
         printf("  RegIntIn=%s,            ! flag to interpolate outputs on regular grid (.TRUE.)\n",RegIntIn)
       }
      else if (substr($1,1,6) == "Binary")
       { 
     	"echo $Binary" | getline Binary
         printf("  Binary=%s,            ! output binary format ! False -> Grib (Default) \n",Binary)
       }
      else if (substr($1,1,6) == "datain")
       { 
        "echo $aspa" | getline aspa
     	"echo $datain" | getline datain
         printf("  datain=%s%s%s,! main dataout directory\n",aspa,datain,aspa)
       }
      else if (substr($1,1,7) == "datalib")
       { 
        "echo $aspa" | getline aspa
     	"echo $datalib" | getline datalib
         printf("  datalib=%s%s%s,! main dataout directory\n",aspa,datalib,aspa)
       }
      else if (substr($1,1,7) == "dataout")
       { 
        "echo $aspa" | getline aspa
     	"echo $dataout" | getline dataout
         printf("  dataout=%s%s%s,! main dataout directory\n",aspa,dataout,aspa)
       }
      else
       {
     	 print $0
       }
     }'    > ${EXECFILEPATH2}/POSTIN-GRIB

cp ${NAMELISTFILEPATH}/geratemplate_grib.bash ${EXECFILEPATH2}/
 
# script invoked by mpirun

cat <<EOF1>${SCRIPTFILEPATH}
#!/bin/bash
#PBS -o ${host}:${EXECFILEPATH2}/setout/Out.post.${PREFIC}.${LABELI}${LABELF}.${tmstp}.%s.MPI${cpu_mpi}.out
#PBS -j oe
#PBS -l walltime=${WALLTIME2}
###############${MPPBS}
##########PBS -l mppnppn=${cpu_node}
####PBS -l mppdepth=${ThreadsperMPITASK}
#PBS -l nodes=${nodes}:ppn=${cpu_node}
#PBS -V
#PBS -S /bin/bash
#PBS -N $RES
#PBS -A ${QUOTA}
#PBS -q ${QUEUE}

export PBS_SERVER=${pbs_server1}

#export OMP_NUM_THREADS=${ThreadsperMPITASK}

if [[ ${MAQUI} == "Linux" || ${MAQUI} == "linux" ]]; then
export F_UFMTENDIAN=10,11
fi
export KMP_STACKSIZE=128m
ulimit -s unlimited
cd ${EXECFILEPATH2}
mkdir -p setout
cp ${EXECFILEPATH}/PostGrib ${EXECFILEPATH2}/PostGrib
sleep 60
optserver=`printf "$PBS_SERVER \n" | cut -c1-3`
if [[ (\${optserver} = "aux") ]]; then
${EXECFILEPATH2}/PostGrib < ${EXECFILEPATH2}/POSTIN-GRIB
else
time aprun -m500h   -n ${cpu_mpi} -N ${cpu_node} ${EXECFILEPATH2}/PostGrib < ${EXECFILEPATH2}/POSTIN-GRIB >> ${EXECFILEPATH2}/setout/Print.post.${PREFIC}.${LABELI}${LABELF}.${tmstp}%s.MPI${cpu_mpi}.out
fi
#for TIPO in P.fct P.fgs S.fct
#do
#sleep 60
#if [ -e ${dataout}/${GPOS}${PREFX}${LABELI}${LABELF}\${TIPO}.${CASE}.lst  ]; then
#for arq in \`cat ${dataout}/${GPOS}${PREFX}${LABELI}${LABELF}\${TIPO}.${CASE}.lst |grep ctl\`
#do
#arq1=\`basename \$arq\`
#chmod -R  755  ${dataout}
## Mapping the GRIB data
#${EXECFILEPATH2}/geratemplate_grib.bash ${LABELI}
#/scratchin/grupos/pad/home/paulo.kubota/grads/2.0.a9/bin/gribmap -i \${dataout}/\${arq1}
#/scratchin/grupos/pad/home/paulo.kubota/grads/2.0.a9/bin/gribmap -i ${dataout}/${GPOS}${PREFX}${LABELI}\${TIPO}.${CASE}.ctl
#
#done
#fi
#done
#sleep 60
#cp -rf ${dataout} /stornext/online8/exp-dmd/paulo.kubota/agcmibis/pos/dataout/${CASE}/
EOF1
#
#   Change mode to be executable
#
chmod +x ${SCRIPTFILEPATH}
cd ${EXECFILEPATH}
/opt/pbs/default/bin/qsub ${SCRIPTFILEPATH}
exit



#qsub $hold ${SCRIPTFILEPATH}
if [[ ${it} -eq 1 ]];then
FIRST=`/opt/pbs/default/bin/qsub ${SCRIPTFILEPATH}`
export FIRST
echo $FIRST
else
SECOND=`/opt/pbs/default/bin/qsub -W depend=afterok:$FIRST ${SCRIPTFILEPATH}`
echo $SECOND
fi
if [ "$hold" == "" ]
then
echo "$hold = NO"
else 
echo "$hold = YES"
itt=2
while [ ${itt} -gt 0 ];do
itt=`qstat @aux20 |grep $RES| wc -l`
itt2=`qstat|grep $RES| wc -l`
let itt=${itt}+${itt2}
sleep 30
done
fi
