#!/bin/bash
#-------------------------------------------------------------------------------------------------#
#                         Brazilian global Atmospheric Model - BAM_V2.2.1                         #
#-------------------------------------------------------------------------------------------------#
#BOP                                                                                              #
# Descrição:                                                                                      #
#     Script com funções utilizadas pelos scripts do modelo BAM                                   #
#                                                                                                 #
# Uso:                                                                                            #
#                                                                                                 #
#                                                                                                 #
# Notas:                                                                                          #
#                                                                                                 #
# Revisões:                                                                                       #
#    * 19-05-2021: de Mattos, J. G. Z.  - Código Inicial                                          #
#                                                                                                 #
# TODO:                                                                                           #
#                                                                                                 #
# DIMNT/CGCT/INPE, 2021                                                                           #
#EOP                                                                                              #
#-------------------------------------------------------------------------------------------------#
whereami(){
    for i in $(seq 0 $((${#FUNCNAME[@]}-1)) );do
       if [ ${FUNCNAME[$i]} == 'main' ];then
          echo $(dirname $(readlink -e ${BASH_SOURCE[$i]}))
          break
       fi
    done
}

assign(){
eval export $1=$2
}


#-----------------------------------------------------------------------------#
# return a subword of a string
#-----------------------------------------------------------------------------#

subwrd(){
   str=$(printf "%s " "${@}" | awk '{ for (i=1; i<=NF-1; i++) printf("%s ",$i)}')
   n=$(printf "%s " "${@}" | awk '{ print $NF }')
   printf "%s " "${str}" | awk -v var=${n} '{print $var}'
}

#-----------------------------------------------------------------------------#
# return usage from main program
#-----------------------------------------------------------------------------#
usage(){
   echo
   echo "Usage:"
   echo " "
   sed -n '/^#BOP/,/^#EOP/{/^#BOP/d;/^#EOP/d;p}' ${1} 
}
#-----------------------------------------------------------------------------#
# Return the maximum value from an Array of arguments
#-----------------------------------------------------------------------------#
max ( ){
   if [ $# -eq 1 ];then
      echo $1
      return 0
   fi
   max=${1}
   for n in ${@} ; do
       ((n > max)) && max=$n
   done
   echo $max
}
#-----------------------------------------------------------------------------#
# Return information about MPI requested resources 
#-----------------------------------------------------------------------------#
getMPIinfo(){


   #
   # set default MPI info
   #

   export MPITasks=240        # Numero de processadores que serao utilizados no Job
   export TasksPerNode=40     # Numero de processadores utilizados por tarefas MPI
   export ThreadsPerMPITask=1 # Number of cores hosting OpenMP threads

   #
   # get MPI info for atual machine
   #
   case $(hostname) in
      clogin*) export MaxTasksPerNode=40;;
      eslogin*) export MaxTasksPerNode=24;;
      *) echo "Unknown Machine $(hostname). ABORT!"; exit 1
   esac

   args=${@} #save arguments temporarily
   while (( $# )); do
      opt=$1
      case ${opt} in
         -np) MPITasks=$2; shift 2 ;;
          -N) TasksPerNode=$2; shift 2;;
          -d) ThreadsPerMPITask=$2; shift 2;;
          -c) CoresPerNode=$2; shift 2;;
          *) echo -e "\033[31;1mWarning:\033[m Unknown argument:\033[33;1m $opt\033[m"; shift 1;;
      esac
   done
   set -- $args #restore arguments


   if [ ${TasksPerNode} -gt ${MaxTasksPerNode} -o ${ThreadsPerMPITask} -gt 1 ];then
      export TasksPerNode=$((${MaxTasksPerNode}/${ThreadsPerMPITask})) # Number of Processors used by each MPI tasks
   fi

   export PEs=$((${MPITasks}/${ThreadsPerMPITask}))
   export Nodes=$(((${MPITasks}+${MaxTasksPerNode}-1)/${MaxTasksPerNode}))
   
}

#-----------------------------------------------------------------------------#
# Get BAM trunc
#-----------------------------------------------------------------------------#
getBAMSize(){

   trunc=${1}

   case ${trunc} in
      21)   IM=64;    JM=32;    timestep=3600;;
      31)   IM=96;    JM=48;    timestep=1800;;
      42)   IM=128;   JM=64;    timestep=1200;;
      62)   IM=192;   JM=96;    timestep=900;;
      106)  IM=320;   JM=160;   timestep=600;;
      126)  IM=384;   JM=192;   timestep=450;;
      133)  IM=400;   JM=200;   timestep=450;;
      159)  IM=480;   JM=240;   timestep=360;;
      170)  IM=512;   JM=256;   timestep=360;;
      213)  IM=640;   JM=320;   timestep=300;;
      254)  IM=768;   JM=384;   timestep=240;;
      299)  IM=900;   JM=450;   timestep=200;;
      319)  IM=960;   JM=480;   timestep=180;;
      341)  IM=1024;  JM=512;   timestep=180;;
      382)  IM=1152;  JM=576;   timestep=150;;
      511)  IM=1536;  JM=768;   timestep=120;;
      533)  IM=1600;  JM=800;   timestep=120;;
      666)  IM=2000;  JM=1000;  timestep=90;;
      863)  IM=2592;  JM=1296;  timestep=60;;
      1279) IM=3840;  JM=1920;  timestep=20;;
      1332) IM=4000;  JM=2000;  timestep=20;;
      *)echo "Truncamento desconhecido ${trunc}"
        return 1
   esac
}

submitPre(){

   #
   # include paths
   #
   . ${WhereIam}/EnvironmentalVariables
 
   #
   #  Run GetSST.ksh
   #  To deGRIB NCEP SST file with the script GetSST.ksh
   #  and to format properly the file for SSTWeekly)
   #
 
   dirEXEC=${SUBTBASE}/pre/exec

   # get MPI requested
   MPITasks=${1}
   TasksPerNode=${2}
   ThreadsPerMPITask=${3}
   labelOut=${4}

   # adjust MPI info from MPI resource requested
   getMPIinfo -np ${MPITasks} -N ${TasksPerNode} -d ${ThreadsPerMPITask}
   

cat <<EOT1 > ${dirEXEC}/pre.qsb
#!/bin/bash
#PBS -o ${dirEXEC}/Out_${labelOut}.MPI${MPITasks}
#PBS -j oe
#PBS -l walltime=00:15:00
#PBS -A CPTEC
#PBS -l nodes=${Nodes}:ppn=${TasksPerNode}
#PBS -V
#PBS -S /bin/bash
#PBS -N ${preEXEC}
#PBS -q pesq

.  /opt/modules/default/etc/modules.sh
module load craype-x86-skylake
#module list
export OMP_WAIT_POLICY=PASSIVE

cd ${dirEXEC}

time aprun -n ${PEs} -N ${TasksPerNode} -d ${ThreadsPerMPITask} ${dirEXEC}/${preEXEC} > saida_${labelOut}.txt
rm -f ${dirExec}/Dump.* > /dev/null 2>&1 
EOT1

cd ${dirEXEC}
PID=$(qsub -W block=true pre.qsb; exit ${PIPESTATUS[0]})
status=$?

chmod 644 ${dirEXEC}/Out_${labelOut}.MPI${MPITasks}
chmod 644 ${dirEXEC}/saida_${labelOut}.txt

return $status

}

function getSST(){
   #
   # include paths
   #
   . ${WhereIam}/EnvironmentalVariables
   
   local PREIN=${SUBTBASE}/pre/datain
 
   #
   # get date from command line
   #

   local runDate=${1}
   local runHour=${runDate:8:2}

   #
   # Output File
   #

   local fileNameOut=gdas1.T%h2Z.sstgrd.%y4%m2%d2%h2

   #
   #  Run GetSST.ksh
   #  To deGRIB NCEP SST file with the script GetSST.ksh
   #  and to format properly the file for SSTWeekly)
   #

   #
   # paths to search (one by line)
   #
   local preDataIn=( \
                    ${SUBTBASE}/pre/datain \
                    ${dadosExternos}/%y4%m2%d2%h2/dataout/NCEP \
                   )
 
   # Possible SST GRIB files:
   # Ondem de importancia
   local files=( \
                rtgssthr_grb_0.083.grib2.%y4%m2%d2 \
                rtgssthr_grb_0.5.grib2.%y4%m2%d2   \
                gdas1.T%h2Z.sstgrb2.%y4%m2%d2%h2 \
                gdas1.T%h2Z.sstgrb.%y4%m2%d2%h2  \
               )

   #
   # start search for sst file
   #

   echo -e "\033[34;1m Getting SST file for:\033[m \033[32;1m${runDate}\033[m"

   local LABELI=${runDate}
   local fileOut=$(${inctime} ${runDate} +0h ${PREIN}/${fileNameOut})
   c=0
   while [ ${c} -le 4 ];do

      echo -en "\033[34;1m Arquivo SST original\033[m "

      for path in ${preDataIn[@]};do

         for file in ${files[@]};do

            local arq=$(${inctime} ${LABELI} +0h ${path}/${file})

            if [ -e ${arq} ];then

               g1=$(${wgrib1} ${arq} 2> /dev/null | wc -l; exit $(max ${PIPESTATUS[@]}) )
               if [ $? -gt 0 ];then
                  echo -e '[ \033[31;1mproblema com o wgrib1, abort\033[m ]'
                  return 1
               fi

               g2=$(${wgrib2} ${arq} 2> /dev/null | wc -l; exit $(max ${PIPESTATUS[@]}))
               if [ $? -gt 0 ];then
                  echo -e '[ \033[31;1mproblema com o wgrib2, abort\033[m ]'
                  return 1
               fi
               if [ $g1 -gt 0 ];then
                  ${wgrib1} -s -4yr -d 1 -ieee  ${arq} -o ${fileOut} > /dev/null 2>&1
                  if [ $? -ne 0 ];then
                     echo -e "\033[31;1m GRIB1: Erro ao converter arquivo ${arq} ... \033[m"
                     return 1
                  else
                     echo -e '\033[33;1m GRIB1: \033[m [\033[32;1m OK \033[m]'
                     return 0
                  fi
               elif [ $g2 -gt 0 ];then
                  ${wgrib2} -s -YY -d 1 -order we:ns  ${arq} -ieee ${fileOut} > /dev/null 2>&1
                  if [ $? -ne 0 ];then
                     echo -e "\033[31;1m GRIB2: Erro ao converter arquivo ${arq} ... \033[m"
                     return 1
                  else
                     echo -e "\033[33;1m GRIB2: \033[m [\033[32;1m OK \033[m]"
                     return 0
                  fi
              fi
              
            fi
         done
      done

      echo -e "[\033[31;1m FAIL \033[m]"

      LABELI=$(${inctime} ${LABELI} -6h %y4%m2%d2%h2)
      if [ ${c} -lt 4 ];then
         echo -e "\033[35;1m buscando em um horário anterior\033[m [\033[33;1m${LABELI}\033[m]"
      fi
      c=$((c+1))

   
      echo -en "\033[34;1m Arquivo convertido previamente \033[m"
      
      prevFile=$(${inctime} ${LABELI} +0h ${PREIN}/${fileNameOut})
      if [ -e ${prevFile} ];then
         echo -e "[\033[32;1m OK \033[m]"
         cp -pvfr ${prevFile}  ${fileOut} > /dev/null 2>&1 
         return 0
      else
         echo -e "[\033[31;1m FAIL \033[m]"
      fi
   done
   echo -e "\033[31;1m Nenhum arquivo SST encontrado, ABORT ... \033[m"
   return 2
}

getSoilFiles(){

  #
  # include paths
  #
  . ${WhereIam}/EnvironmentalVariables

  PREIN=${SUBTBASE}/pre/datain

  #
  # get date from command line
  #

  runDate=${1}

  #
  # soil moisture File
  #

  smcFile=GL_SM.GPNR.%y4%m2%d2%h2.vfm


  #
  # paths to search (one by line)
  #
  local preDataIn=( \
                   ${SUBTBASE}/pre/datain \
                   ${dadosExternos}/%y4%m2%d2%h2/dataout/Umid_Solo \
                  )

  echo -e "\033[34;1m Getting Soil Moisture file for:\033[m \033[32;1m${runDate}\033[m"

  LABELI=${runDate}
  fileOut=$( ${inctime} ${runDate} +0h ${PREIN}/${smcFile} )

  count=0
  while [ ${count} -le 3 ];do
     for path in ${preDataIn[@]};do
        file=$( ${inctime} ${LABELI} +0h ${path}/${smcFile} )
        if [ -e ${file} ];then
           ln -s ${file} ${fileOut} > /dev/null 2>&1
           return 0
        fi
     done
     LABELI=$( ${inctime} ${LABELI} -6h %y4%m2%d2%h2) 
     count=$((count+1))
  done
  echo -e "\033[32;1m Soil moisture file for\033[m: \033[34;1m${runDate}\033[m \033[32;1m Not Found\033[m"
  return -1

}

getAnlNCEP(){
  #
  # include paths
  #
  . ${WhereIam}/EnvironmentalVariables

  #
  # get date from command line
  #

  local runDate=${1}
  local prefix=${2}

  #
  # search for ncep atmospheric anl file
  #

  local preDataIn=${SUBTBASE}/pre/datain

  #
  # path to search
  # 

  preInDir=${preDataIn}
  preInDir=${preInDir}:${dadosExternos}/${runDate}/dataout/NCEP

  local IFS=":"; read -a preInPath < <(echo "${preInDir}")
  local npaths=${#preInPath[@]}; local IFS=" "

  #
  # default ncep anl prefix and sulfix
  #

  local pfx=(gdas gdas1 gblav)
  local sfx=(SAnl atmanl.nemsio atmanl.netcdf)

  #
  #--------------------------------------------------------------
  #

  echo -e "\033[34;1m Getting NCEP analysis file for:\033[m \033[32;1m${runDate}\033[m"

  local hour=${runDate:8:2}
  local files=()
  if [ -z ${2} ];then
     for p in ${pfx[@]};do
        for s in ${sfx[@]};do
            files+=( ${p}.T${hour}Z.${s}.${runDate} )
        done
     done
  else
     for s in ${sfx[@]};do
        files+=( ${prefix}.T${hour}Z.${s}.${runDate} )
     done
  fi
  
  local i=0
  while [ ${i} -le $((npaths-1)) ];do
     for file in ${files[@]};do
        local fileAnl=${preInPath[$[i]]}/${file}
        if [ -e ${fileAnl} ];then
           if [ ${preInPath[$i]} != ${preDataIn} ];then
              ln -s ${fileAnl} ${preDataIn}/${file} > /dev/null 2>&1
           fi
           export GDASPrefix=${file%%.*}
           return 0
        fi
     done
     i=$((i+1))
  done

  #
  # If no file are found, return -1
  #
  return -1

}
